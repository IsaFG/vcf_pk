########### [Code] Method to create a table from a specific annotation ########
getSpecAnnotTable <- function(annotation, subAnnotation, annotVCFTable) {
############# [Code] Load libraries #############
# library(RCurl)
library(jsonlite) #
library(dplyr)
# library(tidyr)
# LEVEL 1
# Get the index of the chosen annotation
index_annot <- grep(annotation, colnames(annotVCFTable))
# Extract, as a single variable, the chosen annotation from the table
element1 <- annotVCFTable[,index_annot]
# NOTE: The class of the element will ALWAYS be "list"
# LEVEL 2
element2_class <- character()
basic_df <- annotVCFTable[,1:5]
subAnnotation_df <- data.frame()
j <- 1
for (element2 in element1) { # for each element (variant) in list
element2_class <- class(element1[[1]])
# LEVEL 3
# Note : level 2 class will almost always be a dataframe (except for repeat)
if (element2_class == "data.frame") {
i <- 1
for (element3 in element2){
element3_class <- class(element3)
if (colnames(element2)[i] == subAnnotation) {
element4_df <- data.frame()
for (element4 in element3) {
element4_df <- cbind(basic_df[j,], element4)
element4_df_class <- lapply(element4_df, class)
k <- 1
for (element5 in element4_df) {
if (class(element5) == "data.frame"){
element4_df[7] <- as.character(element4_df[7])
}
k <- k + 1
}
subAnnotation_df <- bind_rows(subAnnotation_df, element4_df)
}
}
i <- i + 1
}
# NOT DONE FOR LIST SINCE ONLY ONE ANNOTATION TABLE HAS THIS SITUATION
} else if (element2_class == "list")  {
for (element3 in element2){
element3_class <- class(element3)
print (element3_class)
}
}
j <- j + 1
}
return(subAnnotation_df)
}
########### [Code] Determinate if running in TERR or standard R version #############
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
############ [TIBCO] Load variables ###############
# Load the annotated table that will be post-processed
# Load the annotated table, stored in memory as a Blob Object created by script "cellbaseR_Query_getVariant"
annotVCFObject <- BlobToSObject(annotVCFTableBlob)
annotVCFTable <- annotVCFObject
########### [TIBCO] Create the REvaluate object ########
subTable <- REvaluate({
# tablesList <- getTablesList(tablesToProcess, specificAnnot_column)
# tablesList
annotation_table <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
},
data = list(getSpecAnnotTable = getSpecAnnotTable, annotation = annotation, subAnnotation = subAnnotation, annotVCFTable = annotVCFTable)
# ,
# REvaluator = Rversion,
# verbose	= TRUE
)
# for (i in (1:length(tablesList))) {
#   # Load each table in a specific variable in global environment
#   table_name <- paste(tablesToProcess[i],"Table", sep="")
#   table_extracted <- tablesList[[i]]
#   assign(table_name, table_extracted)
#   }
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Set the annotation which needs a post-processing ############
# Pre-set the variable that you want to post-process
annotation <- "consequenceTypes"
subAnnotation <- "sequenceOntologyTerms"
annotation <- "traitAssociation"
subAnnotation <- "genomicFeatures" # NO SIRVE
annotation <- "traitAssociation"
subAnnotation <- "additionalProperties"
subAnnotation <- "heritableTraits"
########### [RStudio] Execute main method ###########
# tablesList <- getTablesList(tablesToProcess, annotVCFTable)
subAnnotation_df <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
########### [RStudio] Save the information ###########
# Load each table in a specific variable in global environment
table_name <- paste(annotation,subAnnotation,"Table", sep="")
assign(table_name, subAnnotation_df)
# Print the table in a txt file
# Works only with basic tables
file_path <- paste("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk\\test_files\\annotatedTables\\annotated_table_",annotation,subAnnotation, ".txt",sep = "")
try(write.table(subAnnotation_df,file_path, append = FALSE, sep="\t",row.names=FALSE))
}
########### [Code] Method to create a table from a specific annotation ########
getSpecAnnotTable <- function(annotation, subAnnotation, annotVCFTable) {
############# [Code] Load libraries #############
# library(RCurl)
library(jsonlite) #
library(dplyr)
# library(tidyr)
# LEVEL 1
# Get the index of the chosen annotation
index_annot <- grep(annotation, colnames(annotVCFTable))
# Extract, as a single variable, the chosen annotation from the table
element1 <- annotVCFTable[,index_annot]
# NOTE: The class of the element will ALWAYS be "list"
# LEVEL 2
element2_class <- character()
basic_df <- annotVCFTable[,1:5]
subAnnotation_df <- data.frame()
j <- 1
for (element2 in element1) { # for each element (variant) in list
element2_class <- class(element1[[1]])
# LEVEL 3
# Note : level 2 class will almost always be a dataframe (except for repeat)
if (element2_class == "data.frame") {
i <- 1
for (element3 in element2){
element3_class <- class(element3)
if (colnames(element2)[i] == subAnnotation) {
element4_df <- data.frame()
for (element4 in element3) {
element4_df <- cbind(basic_df[j,], element4)
element4_df_class <- lapply(element4_df, class)
k <- 1
for (element5 in element4_df) {
if (class(element5) == "data.frame"){
element4_df[7] <- as.character(element4_df[7])
}
k <- k + 1
}
subAnnotation_df <- bind_rows(subAnnotation_df, element4_df)
}
}
i <- i + 1
}
# NOT DONE FOR LIST SINCE ONLY ONE ANNOTATION TABLE HAS THIS SITUATION
} else if (element2_class == "list")  {
for (element3 in element2){
element3_class <- class(element3)
print (element3_class)
}
}
j <- j + 1
}
return(subAnnotation_df)
}
########### [Code] Determinate if running in TERR or standard R version #############
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
############ [TIBCO] Load variables ###############
# Load the annotated table that will be post-processed
# Load the annotated table, stored in memory as a Blob Object created by script "cellbaseR_Query_getVariant"
annotVCFObject <- BlobToSObject(annotVCFTableBlob)
annotVCFTable <- annotVCFObject
########### [TIBCO] Create the REvaluate object ########
subTable <- REvaluate({
# tablesList <- getTablesList(tablesToProcess, specificAnnot_column)
# tablesList
annotation_table <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
},
data = list(getSpecAnnotTable = getSpecAnnotTable, annotation = annotation, subAnnotation = subAnnotation, annotVCFTable = annotVCFTable)
# ,
# REvaluator = Rversion,
# verbose	= TRUE
)
# for (i in (1:length(tablesList))) {
#   # Load each table in a specific variable in global environment
#   table_name <- paste(tablesToProcess[i],"Table", sep="")
#   table_extracted <- tablesList[[i]]
#   assign(table_name, table_extracted)
#   }
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Set the annotation which needs a post-processing ############
# Pre-set the variable that you want to post-process
annotation <- "consequenceTypes"
subAnnotation <- "sequenceOntologyTerms"
annotation <- "traitAssociation"
subAnnotation <- "genomicFeatures" # NO SIRVE
annotation <- "traitAssociation"
subAnnotation <- "additionalProperties"
subAnnotation <- "heritableTraits"
########### [RStudio] Execute main method ###########
# tablesList <- getTablesList(tablesToProcess, annotVCFTable)
subAnnotation_df <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
########### [RStudio] Save the information ###########
# # Load each table in a specific variable in global environment
# table_name <- paste(annotation,subAnnotation,"Table", sep="")
# assign(table_name, subAnnotation_df)
# # Print the table in a txt file
# # Works only with basic tables
# file_path <- paste("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk\\test_files\\annotatedTables\\annotated_table_",annotation,subAnnotation, ".txt",sep = "")
# try(write.table(subAnnotation_df,file_path, append = FALSE, sep="\t",row.names=FALSE))
#
}
# LEVEL 1
# Get the index of the chosen annotation
index_annot <- grep(annotation, colnames(annotVCFTable))
# Extract, as a single variable, the chosen annotation from the table
element1 <- annotVCFTable[,index_annot]
# LEVEL 2
element2_class <- character()
basic_df <- annotVCFTable[,1:5]
subAnnotation_df <- data.frame()
j <- 1
for (element2 in element1) { # for each element (variant) in list
element2_class <- class(element1[[1]])
# LEVEL 3
# Note : level 2 class will almost always be a dataframe (except for repeat)
if (element2_class == "data.frame") {
i <- 1
for (element3 in element2){
element3_class <- class(element3)
if (colnames(element2)[i] == subAnnotation) {
element4_df <- data.frame()
for (element4 in element3) {
element4_df <- cbind(basic_df[j,], element4)
element4_df_class <- lapply(element4_df, class)
k <- 1
for (element5 in element4_df) {
if (class(element5) == "data.frame"){
element4_df[7] <- as.character(element4_df[7])
}
k <- k + 1
}
subAnnotation_df <- bind_rows(subAnnotation_df, element4_df)
}
}
i <- i + 1
}
# NOT DONE FOR LIST SINCE ONLY ONE ANNOTATION TABLE HAS THIS SITUATION
} else if (element2_class == "list")  {
for (element3 in element2){
element3_class <- class(element3)
print (element3_class)
}
}
j <- j + 1
}
View(subAnnotation_df)
View(element4_df)
View(element3)
element3_class
for (element4 in element3) {
element4_df <- cbind(basic_df[j,], element4)
element4_df_class <- lapply(element4_df, class)
k <- 1
for (element5 in element4_df) {
if (class(element5) == "data.frame"){
element4_df[7] <- as.character(element4_df[7])
}
k <- k + 1
}
subAnnotation_df <- bind_rows(subAnnotation_df, element4_df)
}
element4_df <- cbind(basic_df[j,], element4)
element4
element3
element4_df
element5
########### [Code] Method to create a table from a specific annotation ########
getSpecAnnotTable <- function(annotation, subAnnotation, annotVCFTable) {
############# [Code] Load libraries #############
# library(RCurl)
library(jsonlite) #
library(dplyr)
# library(tidyr)
# LEVEL 1
# Get the index of the chosen annotation
index_annot <- grep(annotation, colnames(annotVCFTable))
# Extract, as a single variable, the chosen annotation from the table
element1 <- annotVCFTable[,index_annot]
# NOTE: The class of the element will ALWAYS be "list"
# LEVEL 2
element2_class <- character()
basic_df <- annotVCFTable[,1:5]
subAnnotation_df <- data.frame()
j <- 1
for (element2 in element1) { # for each element (variant) in list
element2_class <- class(element1[[1]])
# LEVEL 3
# Note : level 2 class will almost always be a dataframe (except for repeat)
if (element2_class == "data.frame") {
i <- 1
for (element3 in element2){
element3_class <- class(element3)
if (colnames(element2)[i] == subAnnotation) {
element4_df <- data.frame()
for (element4 in element3) {
if (is.null(element4)) {
element4_df <- basic_df[j,]
} else {element4_df <- cbind(basic_df[j,], element4)
}
element4_df_class <- lapply(element4_df, class)
k <- 1
for (element5 in element4_df) {
if (class(element5) == "data.frame"){
element4_df[7] <- as.character(element4_df[7])
}
k <- k + 1
}
subAnnotation_df <- bind_rows(subAnnotation_df, element4_df)
}
}
i <- i + 1
}
# NOT DONE FOR LIST SINCE ONLY ONE ANNOTATION TABLE HAS THIS SITUATION
} else if (element2_class == "list")  {
for (element3 in element2){
element3_class <- class(element3)
print (element3_class)
}
}
j <- j + 1
}
return(subAnnotation_df)
}
########### [Code] Determinate if running in TERR or standard R version #############
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
############ [TIBCO] Load variables ###############
# Load the annotated table that will be post-processed
# Load the annotated table, stored in memory as a Blob Object created by script "cellbaseR_Query_getVariant"
annotVCFObject <- BlobToSObject(annotVCFTableBlob)
annotVCFTable <- annotVCFObject
########### [TIBCO] Create the REvaluate object ########
subTable <- REvaluate({
# tablesList <- getTablesList(tablesToProcess, specificAnnot_column)
# tablesList
annotation_table <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
},
data = list(getSpecAnnotTable = getSpecAnnotTable, annotation = annotation, subAnnotation = subAnnotation, annotVCFTable = annotVCFTable)
# ,
# REvaluator = Rversion,
# verbose	= TRUE
)
# for (i in (1:length(tablesList))) {
#   # Load each table in a specific variable in global environment
#   table_name <- paste(tablesToProcess[i],"Table", sep="")
#   table_extracted <- tablesList[[i]]
#   assign(table_name, table_extracted)
#   }
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Set the annotation which needs a post-processing ############
# Pre-set the variable that you want to post-process
annotation <- "consequenceTypes"
subAnnotation <- "sequenceOntologyTerms"
annotation <- "traitAssociation"
subAnnotation <- "genomicFeatures" # NO SIRVE
annotation <- "traitAssociation"
subAnnotation <- "additionalProperties"
subAnnotation <- "heritableTraits"
########### [RStudio] Execute main method ###########
# tablesList <- getTablesList(tablesToProcess, annotVCFTable)
subAnnotation_df <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
########### [RStudio] Save the information ###########
# # Load each table in a specific variable in global environment
# table_name <- paste(annotation,subAnnotation,"Table", sep="")
# assign(table_name, subAnnotation_df)
# # Print the table in a txt file
# # Works only with basic tables
# file_path <- paste("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk\\test_files\\annotatedTables\\annotated_table_",annotation,subAnnotation, ".txt",sep = "")
# try(write.table(subAnnotation_df,file_path, append = FALSE, sep="\t",row.names=FALSE))
#
}
load("~/GitHub/vcf_pk/NA12878.chr.22.RData")
########### [Code] Method to create a table from a specific annotation ########
getSpecAnnotTable <- function(annotation, subAnnotation, annotVCFTable) {
############# [Code] Load libraries #############
# library(RCurl)
library(jsonlite) #
library(dplyr)
# library(tidyr)
# LEVEL 1
# Get the index of the chosen annotation
index_annot <- grep(annotation, colnames(annotVCFTable))
# Extract, as a single variable, the chosen annotation from the table
element1 <- annotVCFTable[,index_annot]
# NOTE: The class of the element will ALWAYS be "list"
# LEVEL 2
element2_class <- character()
basic_df <- annotVCFTable[,1:5]
subAnnotation_df <- data.frame()
j <- 1
for (element2 in element1) { # for each element (variant) in list
element2_class <- class(element1[[1]])
# LEVEL 3
# Note : level 2 class will almost always be a dataframe (except for repeat)
if (element2_class == "data.frame") {
i <- 1
for (element3 in element2){
element3_class <- class(element3)
if (colnames(element2)[i] == subAnnotation) {
element4_df <- data.frame()
for (element4 in element3) {
if (is.null(element4)) {
element4_df <- basic_df[j,]
} else {element4_df <- cbind(basic_df[j,], element4)
}
element4_df_class <- lapply(element4_df, class)
k <- 1
for (element5 in element4_df) {
if (class(element5) == "data.frame"){
element4_df[7] <- as.character(element4_df[7])
}
k <- k + 1
}
subAnnotation_df <- bind_rows(subAnnotation_df, element4_df)
}
}
i <- i + 1
}
# NOT DONE FOR LIST SINCE ONLY ONE ANNOTATION TABLE HAS THIS SITUATION
} else if (element2_class == "list")  {
for (element3 in element2){
element3_class <- class(element3)
print (element3_class)
}
}
j <- j + 1
}
return(subAnnotation_df)
}
########### [Code] Determinate if running in TERR or standard R version #############
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
############ [TIBCO] Load variables ###############
# Load the annotated table that will be post-processed
# Load the annotated table, stored in memory as a Blob Object created by script "cellbaseR_Query_getVariant"
annotVCFObject <- BlobToSObject(annotVCFTableBlob)
annotVCFTable <- annotVCFObject
########### [TIBCO] Create the REvaluate object ########
subTable <- REvaluate({
# tablesList <- getTablesList(tablesToProcess, specificAnnot_column)
# tablesList
annotation_table <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
},
data = list(getSpecAnnotTable = getSpecAnnotTable, annotation = annotation, subAnnotation = subAnnotation, annotVCFTable = annotVCFTable)
# ,
# REvaluator = Rversion,
# verbose	= TRUE
)
# for (i in (1:length(tablesList))) {
#   # Load each table in a specific variable in global environment
#   table_name <- paste(tablesToProcess[i],"Table", sep="")
#   table_extracted <- tablesList[[i]]
#   assign(table_name, table_extracted)
#   }
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Set the annotation which needs a post-processing ############
# Pre-set the variable that you want to post-process
annotation <- "consequenceTypes"
subAnnotation <- "sequenceOntologyTerms"
annotation <- "traitAssociation"
subAnnotation <- "genomicFeatures" # NO SIRVE
annotation <- "traitAssociation"
subAnnotation <- "additionalProperties"
subAnnotation <- "heritableTraits"
########### [RStudio] Execute main method ###########
# tablesList <- getTablesList(tablesToProcess, annotVCFTable)
subAnnotation_df <- getSpecAnnotTable(annotation, subAnnotation, annotVCFTable)
########### [RStudio] Save the information ###########
# Load each table in a specific variable in global environment
table_name <- paste(annotation,subAnnotation,"Table", sep="")
assign(table_name, subAnnotation_df)
# Print the table in a txt file
# Works only with basic tables
file_path <- paste("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk\\test_files\\annotatedTables\\annotated_table_",annotation,subAnnotation, ".txt",sep = "")
try(write.table(subAnnotation_df,file_path, append = FALSE, sep="\t",row.names=FALSE))
}
View(subAnnotation_df)
load("~/GitHub/vcf_pk/NA12878.chr.22.RData")
View(annotVCFTable)
load("~/GitHub/vcf_pk/NA12878.chr.22_allTables.RData")
View(consequenceTypesTable)
View(annotVCFTable)
