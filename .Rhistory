chosen_annot = availableAnnots[8]
# availableAnnots, basicTable, annotVariants_table
# They should already be loaded in global environment and come from script 3.cellbaseR_Query_getVariant
########### [RStudio] Execute main method ###########
chosen_annot_table <- getChosenAnnotTable(chosen_annot, basicTable, annotVariants_table)
########### [RStudio] Print the table in a txt file ###########
# Works only with basic table
file_path <- paste("test_files\\annotated_table_",chosen_annot, ".txt",sep = "")
try(write.table(chosen_annot_table,file_path, append = FALSE, sep="\t",row.names=FALSE))
}
index_annot <- grep(chosen_annot, colnames(annotVariants_table))
annot_column <- annotVariants_table[,index_annot]
chosen_annot_table <- data.frame()
column_classes <- lapply(annot_column, class)
i = 1
for (annot_cell in annot_column) {
# Print info of the cell being analyzed
print (paste("Variant", i, "with class", class(annot_cell), "and lenght:",length(annot_cell)))
print (paste("dimension",(dim(annot_cell))))
# Assign variables to start the analyze
data_class <- class(annot_cell)
data_length <- length(annot_cell)
basic_row <- basicTable[i,]
# print (str(annot_column[i])) # testing line
if (data_length == 0) { # In case the cell would have no result for this annotation
print ("Processing empty cell")
annotated_row <- basic_row
# annotated_row[, chosen_annot] <- "No result"
} else if (data_class == "data.frame") { # In case the cell would contain a dataframe
# Apply the function  to produce a row/df from the cell
annotation_row <- simplifyDFcell(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else if (data_class == "list") { # In case the cell would contain a list
annotation_row <- as.character(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else {# In case the cell is not problematic
annotation_row <- annot_cell
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
}
print ("Building the annotated table") # testing line
chosen_annot_table <- bind_rows(chosen_annot_table, annotated_row)
i = i + 1
print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")# testing line
}
cell_to_convert <- annot_cell
simplifyDFcell <- function (cell_to_convert) {
print ("Processing a dataframe") # testing line
# Create a new dataframe from the cell
cell_df <- data.frame(cell_to_convert)
# To know what classes are inside the dataframe
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
# Check if there still are a dataframe inside the new dataframe
if (match('data.frame',classes_vec)) {
cell_df <- flatten(cell_df)
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
}
# Check if there is a list inside the new dataframe
i <- 1
for (class in classes_vec) {
if (class == "list") {
cell_df[,i] <- as.character(cell_df[,i])
}
i <- i + 1
}
# The result will be a new row created from the cell
return(cell_df)
}
index_annot <- grep(chosen_annot, colnames(annotVariants_table))
annot_column <- annotVariants_table[,index_annot]
chosen_annot_table <- data.frame()
column_classes <- lapply(annot_column, class)
i = 1
for (annot_cell in annot_column) {
# Print info of the cell being analyzed
print (paste("Variant", i, "with class", class(annot_cell), "and lenght:",length(annot_cell)))
print (paste("dimension",(dim(annot_cell))))
# Assign variables to start the analyze
data_class <- class(annot_cell)
data_length <- length(annot_cell)
basic_row <- basicTable[i,]
# print (str(annot_column[i])) # testing line
if (data_length == 0) { # In case the cell would have no result for this annotation
print ("Processing empty cell")
annotated_row <- basic_row
# annotated_row[, chosen_annot] <- "No result"
} else if (data_class == "data.frame") { # In case the cell would contain a dataframe
# Apply the function  to produce a row/df from the cell
annotation_row <- simplifyDFcell(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else if (data_class == "list") { # In case the cell would contain a list
annotation_row <- as.character(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else {# In case the cell is not problematic
annotation_row <- annot_cell
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
}
print ("Building the annotated table") # testing line
chosen_annot_table <- bind_rows(chosen_annot_table, annotated_row)
i = i + 1
print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")# testing line
}
cell_to_convert <- annot_cell
annot_cell
View(annot_cell)
TEST_classes <- lapply(chosen_annot_table, class)
TEST_classes
cell_df <- data.frame(cell_to_convert)
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
class_info
if (match('data.frame',classes_vec)) {
cell_df <- flatten(cell_df)
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
}
classes_vec
match('data.frame',classes_vec)
if ('data.frame' %in% classes_vec) {
cell_df <- flatten(cell_df)
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
}
'data.frame' %in% classes_vec
colnames(annotVariants_table
colnames(annotVariants_table)
View(annotVariants_table)
colnames(annotVariants_table)[5] <- "rsID"
getAnnotVariantsTable <- function(variants_table) {
############# [Code] Load libraries #############
library(RCurl)
library(jsonlite)
library(cellbaseR)
library(dplyr)
library(tidyr)
############# [Code] Build the GET URL and query CellBase (CellBaseR) ############
var_number <- nrow(variants_table)
cb <- CellBaseR()
# Initialize the annotation table
annotVariants_table <- data.frame()
# Initialize a table to record any problem about dimensions in the annotated table
problems <- data.frame(variant=integer(0), column=integer(0), dimension=integer(0), class=character(0)) # testing line
for (i in 1:var_number) {
print (paste("Processing variant number:", i)) # this line is for testing
# extract the chromosome
var_chrom <- variants_table[i,1]
# extract the range
var_range <- variants_table[i,2]
# extract the ref and alt alleles
# WARNING: you could have more than one allele in each field
# so that this formula extract only the first one to do the annotation call
# IS THAT A GOOD APPROACH ?
var_refAl <- substring((variants_table[i,4]), 1, 1)
var_altAl <- substring((variants_table[i,5]), 1, 1)
# Get variant cellbase info with cellbaseR package
# the call will return as a data.frame
variant <- paste(var_chrom, ":", var_range, ":", var_refAl, ":", var_altAl, sep = "")
annotVariant <- getVariant(object=cb, ids=variant, resource="annotation")
# set the vector of column dimension to 0
# This is important to control calls that return data.frame with dimension problems
columns_dim <- integer()
if (nrow(annotVariant)==0) { # if the call returns an empty data.frame
print (paste("WARNING for variant", i, "EMPTY RESULT!"))
# build the data.frame with the available information
annotVariant <- data.frame(var_chrom, as.integer(var_range), var_refAl, var_altAl)
colnames(annotVariant) <- c("chromosome", "start", "reference", "alternate")
annotVariants_table <- bind_rows(annotVariants_table, annotVariant)
} else {
# control the dimension of each column in the dataframe
for (column in annotVariant) {
columns_dim <- c(columns_dim, dim(column))
}
# normal situation, no column with dimension > 1
if (length(columns_dim) == 0) {
annotVariants_table <- bind_rows(annotVariants_table, annotVariant)
} else {
# anormal situation, there is one or more columns with dimension > 0
print (paste("WARNING for variant", i, "MULTIDIMENSIONAL column(s)"))
# assign the data.frame to a new variable
annotVariant_sub <- annotVariant
# Scan the data.frame in order to find the problematic column(s)
print (paste("Analyzing columns of variant", i)) # testing line
k = 1
for (column in annotVariant) {
# extract class and dimension of the problematic column
the_class <- class(column)
the_dim <- dim(column)
if (length(the_dim) != 0){ # only for columns with problem
print (paste("Column", k, "has a dimensional problem.")) # testing line
# Remove the problematic column, split it and add it again to the dataframe
annotVariant_sub <- cbind(annotVariant[,-k], column[1], column[2])
# To record variants with dimensional problem
variant = i
column = k
class = the_class
dimension = the_dim
one_problem <- data.frame(variant, column, dimension, class)
problems <- bind_rows(problems, one_problem)
}
k = k + 1
}
# Build the table with all the annotation
annotVariants_table <- bind_rows(annotVariants_table, annotVariant_sub)
}
}
# warnings()
}
# Change the name of the "id" column to avoid repetition
colnames(annotVariants_table)[5] <- "rsID"
return(annotVariants_table)
}
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
########### [TIBCO] Create the REvaluate object to execute main method ########
annotVariants_table <- REvaluate({
annotVariants_table <- getAnnotVariantsTable(variants_table)
annotVariants_table
}
, data = list(getAnnotVariantsTable = getAnnotVariantsTable, variants_table = variants_table)
# , REvaluator = Rversion
# , verbose	= TRUE
)
########### [TIBCO] Comvert the table to a Blob Object ########
annotVariantsBlob <- SObjectToBlob(annotVariants_table)
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Get the variants table ############
variants_table <- read.table("test_files\\variants_table.txt", header=TRUE) # for RStudio
########### [RStudio] Execute main method ###########
annotVariants_table <- getAnnotVariantsTable(variants_table)
########### [RStudio] Print the basic table in a txt file ###########
# Works only with basic table
try(write.table(annotVariants_table[,1:5],"test_files\\CB_variants_table.txt", append = FALSE, sep="\t",row.names=FALSE))
}
basicTable <- annotVariants_table[,1:5]
availableAnnots <- colnames(annotVariants_table[6:length(annotVariants_table)])
View(basicTable)
getChosenAnnotTable <- function(chosen_annot, basicTable, annotVariants_table) {
############# [Code] Load libraries #############
library(RCurl)
library(jsonlite)
library(cellbaseR)
library(dplyr)
library(tidyr)
############# [Code] Method to process cells containing a dataframe #############
# This function will convert any cell containing a dataframe in readable information
# cell_to_convert <- annot_cell # For TESTING purpose
simplifyDFcell <- function (cell_to_convert) {
print ("Processing a dataframe") # testing line
# Create a new dataframe from the cell
cell_df <- data.frame(cell_to_convert)
# To know what classes are inside the dataframe
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
# Check if there still are a dataframe inside the new dataframe
if ('data.frame' %in% classes_vec) {
cell_df <- flatten(cell_df)
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
}
# Check if there is a list inside the new dataframe
i <- 1
for (class in classes_vec) {
if (class == "list") {
cell_df[,i] <- as.character(cell_df[,i])
}
i <- i + 1
}
# The result will be a new row created from the cell
return(cell_df)
}
############# [Code] Main method ############
# Get the index of the chosen annotation
index_annot <- grep(chosen_annot, colnames(annotVariants_table))
# Extract, as a single variable, the chosen annotation from the table
annot_column <- annotVariants_table[,index_annot]
# Declare the dataframe that will contain all the info of the chosen annotation
chosen_annot_table <- data.frame()
# Determinate the class of all the cells inside the column
column_classes <- lapply(annot_column, class)
# For each cell of the annotation column, loop to extact the content of the cell
i = 1
for (annot_cell in annot_column) {
# Print info of the cell being analyzed
print (paste("Variant", i, "with class", class(annot_cell), "and lenght:",length(annot_cell)))
print (paste("dimension",(dim(annot_cell))))
# Assign variables to start the analyze
data_class <- class(annot_cell)
data_length <- length(annot_cell)
basic_row <- basicTable[i,]
# print (str(annot_column[i])) # testing line
if (data_length == 0) { # In case the cell would have no result for this annotation
print ("Processing empty cell")
annotated_row <- basic_row
# annotated_row[, chosen_annot] <- "No result"
} else if (data_class == "data.frame") { # In case the cell would contain a dataframe
# Apply the function  to produce a row/df from the cell
annotation_row <- simplifyDFcell(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else if (data_class == "list") { # In case the cell would contain a list
annotation_row <- as.character(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else {# In case the cell is not problematic
annotation_row <- annot_cell
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
}
print ("Building the annotated table") # testing line
chosen_annot_table <- bind_rows(chosen_annot_table, annotated_row)
i = i + 1
print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")# testing line
}
return(chosen_annot_table)
}
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
############ [TIBCO] Load variables ###############
# Load the annotated table, stored in memory as a Blob Object created by script "cellbaseR_Query_getVariant"
annotVariantsSObject <- BlobToSObject(annotVariantsBlob)
annotVariants_table <- annotVariantsSObject
# For testing prupose: you can pre-set the annotation "geneDrugInteraction"
# chosen_annot <- availableAnnots[12]
########### [TIBCO] Create the REvaluate object ########
AnnotatedTable <- REvaluate({
chosen_annot_table <- getChosenAnnotTable(chosen_annot, basicTable, annotVariants_table)
chosen_annot_table
},
data = list(getChosenAnnotTable = getChosenAnnotTable, annotVariants_table = annotVariants_table, chosen_annot = chosen_annot, basicTable = basicTable)
# ,
# REvaluator = Rversion,
# verbose	= TRUE
)
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Get the input variables ############
chosen_annot = availableAnnots[8]
# availableAnnots, basicTable, annotVariants_table
# They should already be loaded in global environment and come from script 3.cellbaseR_Query_getVariant
########### [RStudio] Execute main method ###########
chosen_annot_table <- getChosenAnnotTable(chosen_annot, basicTable, annotVariants_table)
########### [RStudio] Print the table in a txt file ###########
# Works only with basic table
file_path <- paste("test_files\\annotated_table_",chosen_annot, ".txt",sep = "")
try(write.table(chosen_annot_table,file_path, append = FALSE, sep="\t",row.names=FALSE))
}
View(chosen_annot_table)
availableAnnots
getChosenAnnotTable <- function(chosen_annot, basicTable, annotVariants_table) {
############# [Code] Load libraries #############
library(RCurl)
library(jsonlite)
library(cellbaseR)
library(dplyr)
library(tidyr)
############# [Code] Method to process cells containing a dataframe #############
# This function will convert any cell containing a dataframe in readable information
# cell_to_convert <- annot_cell # For TESTING purpose
simplifyDFcell <- function (cell_to_convert) {
print ("Processing a dataframe") # testing line
# Create a new dataframe from the cell
cell_df <- data.frame(cell_to_convert)
# To know what classes are inside the dataframe
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
# Check if there still are a dataframe inside the new dataframe
if ('data.frame' %in% classes_vec) {
cell_df <- flatten(cell_df)
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
}
# Check if there is a list inside the new dataframe
i <- 1
for (class in classes_vec) {
if (class == "list") {
cell_df[,i] <- as.character(cell_df[,i])
}
i <- i + 1
}
# The result will be a new row created from the cell
return(cell_df)
}
############# [Code] Main method ############
# Get the index of the chosen annotation
index_annot <- grep(chosen_annot, colnames(annotVariants_table))
# Extract, as a single variable, the chosen annotation from the table
annot_column <- annotVariants_table[,index_annot]
# Declare the dataframe that will contain all the info of the chosen annotation
chosen_annot_table <- data.frame()
# Determinate the class of all the cells inside the column
column_classes <- lapply(annot_column, class)
# For each cell of the annotation column, loop to extact the content of the cell
i = 1
for (annot_cell in annot_column) {
# Print info of the cell being analyzed
print (paste("Variant", i, "with class", class(annot_cell), "and lenght:",length(annot_cell)))
print (paste("dimension",(dim(annot_cell))))
# Assign variables to start the analyze
data_class <- class(annot_cell)
data_length <- length(annot_cell)
basic_row <- basicTable[i,]
# print (str(annot_column[i])) # testing line
if (data_length == 0) { # In case the cell would have no result for this annotation
print ("Processing empty cell")
annotated_row <- basic_row
# annotated_row[, chosen_annot] <- "No result"
} else if (data_class == "data.frame") { # In case the cell would contain a dataframe
# Apply the function  to produce a row/df from the cell
annotation_row <- simplifyDFcell(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else if (data_class == "list") { # In case the cell would contain a list
annotation_row <- as.character(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else {# In case the cell is not problematic
annotation_row <- annot_cell
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
}
print ("Building the annotated table") # testing line
chosen_annot_table <- bind_rows(chosen_annot_table, annotated_row)
i = i + 1
print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")# testing line
}
return(chosen_annot_table)
}
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
############ [TIBCO] Load variables ###############
# Load the annotated table, stored in memory as a Blob Object created by script "cellbaseR_Query_getVariant"
annotVariantsSObject <- BlobToSObject(annotVariantsBlob)
annotVariants_table <- annotVariantsSObject
# For testing prupose: you can pre-set the annotation "geneDrugInteraction"
# chosen_annot <- availableAnnots[12]
########### [TIBCO] Create the REvaluate object ########
AnnotatedTable <- REvaluate({
chosen_annot_table <- getChosenAnnotTable(chosen_annot, basicTable, annotVariants_table)
chosen_annot_table
},
data = list(getChosenAnnotTable = getChosenAnnotTable, annotVariants_table = annotVariants_table, chosen_annot = chosen_annot, basicTable = basicTable)
# ,
# REvaluator = Rversion,
# verbose	= TRUE
)
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Get the input variables ############
chosen_annot = availableAnnots[6]
# availableAnnots, basicTable, annotVariants_table
# They should already be loaded in global environment and come from script 3.cellbaseR_Query_getVariant
########### [RStudio] Execute main method ###########
chosen_annot_table <- getChosenAnnotTable(chosen_annot, basicTable, annotVariants_table)
########### [RStudio] Print the table in a txt file ###########
# Works only with basic table
file_path <- paste("test_files\\annotated_table_",chosen_annot, ".txt",sep = "")
try(write.table(chosen_annot_table,file_path, append = FALSE, sep="\t",row.names=FALSE))
}
View(chosen_annot_table)
View(basicTable)
variants_vct <- basicTable$rsID
common_URL <- "http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/"
category_URL <- "clinical/variant/search"
subcategory_URL <- N/A
parameters_URL <- "limit=-1&skip=-1&skipCount=false&count=false&Output%20format=json"
URL_vector <- character()
for (variantID in variants_vct) {
# build a query like this one :
# http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/clinical/variant/search?limit=-1&skip=-1&skipCount=false&count=false&Output%20format=json&id=rs6025
# Get the Swagger link
URL_base <- paste(common_URL,category_URL,"?",parameters_URL,"&id=",variantID,sep = "")
URL_vector <- c(URL_vector, URL_base)
}
URL_vector
