# version corta :
# http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation
library(RCurl)
library(jsonlite)
# guardar el enlace en el objeto query. Para eso se usa la funcion geturl de Rcurl, que descarga URLs
query<-getURL("http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation")
# esta direccion se puede pegar en el navegador para ver la pinta que tiene
# TEST CON OTRA URL
# query <-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/genomic/region/1:18149476-18149476/gene")
# en esta query tenemos lo que es el JSON. Tipo : Large character
query # podemos mostrar el JSON en pantalla
sink("query.txt")
query
sink()
# almacenamos el contenido json de la url en un objeto tipo lista
# este objeto contiene pues toda la informacion de los genes solicitados
querydf<-fromJSON(query)
querydf # CUIDADO esto cuelga R con datos masivos
sink("querydf.txt")
querydf
sink()
## NOTA : warning, error y response estan en la primera linea de la URL
## NOTA : el contenido response es todo el resto
#Get any warnings that may be worth noting
query_warnings<-querydf$warning
#Get any errors produced by the query
query_errors<-querydf$error
# conseguir la respuesta a la query
# nos da un query_result de 3 observaciones (los genes) de 9 variables
query_result<-querydf$response
query_result  # CUIDADO esto cuelga R con datos masivos
sink("query_result.txt")
query_result
sink()
# Create a table with the number of responses from each of the queries:
# crear una tabla con el numero de respuestas para cada una de las queries
query_stats<-data.frame(query_result[c("id","numTotalResults","numResults")])
names(query_stats)[1]<-"query"
query_stats
sink("query_stats.txt")
query_stats
sink()
# Filter from the result list the output of those queries that produced no result
# filtrar de la lista de resultados los outputs de aquellas queries que no devuelven resultado
queries_with_results<- rowSums(query_stats[,c(2,3)])>0
queries_with_results
retrieved_results<-query_result$result[queries_with_results]
retrieved_results  # CUIDADO esto cuelga R con datos masivos
sink("retrieved_results.txt")
retrieved_results
sink()
# test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description,retrieved_results[[1]]$drugInteractions)
test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description)
test
sink("tessst.txt")
test
sink()
class(retrieved_results)
do.call(rbind.data.frame, retrieved_results)
results_DF <- do.call(rbind.data.frame, retrieved_results)
sink("retrieved_results.txt")
sink()
sink("results_DF")
results_DF
sink()
class(results_DF)
# EJEMPLO 1 DEL API
# Ejemplo usando la primera variante
# que encontramos en el VCF file usado como ejemplo
#### first variant found in the VCF file used as example
#### -> chr1 - 18149476 - Ref:G and Alt:A
# COn este link obtenemos anotación para la variante seleccionada
# "http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation?limit=-1&skip=-1&count=false&Output%20format=json&normalize=false
# version corta :
# http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation
library(RCurl)
library(jsonlite)
# guardar el enlace en el objeto query. Para eso se usa la funcion geturl de Rcurl, que descarga URLs
query<-getURL("http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation")
# esta direccion se puede pegar en el navegador para ver la pinta que tiene
# TEST CON OTRA URL
# query <-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/genomic/region/1:18149476-18149476/gene")
# en esta query tenemos lo que es el JSON. Tipo : Large character
query # podemos mostrar el JSON en pantalla
sink("query.txt")
query
sink()
# almacenamos el contenido json de la url en un objeto tipo lista
# este objeto contiene pues toda la informacion de los genes solicitados
querydf<-fromJSON(query)
querydf # CUIDADO esto cuelga R con datos masivos
sink("querydf.txt")
querydf
sink()
## NOTA : warning, error y response estan en la primera linea de la URL
## NOTA : el contenido response es todo el resto
#Get any warnings that may be worth noting
query_warnings<-querydf$warning
#Get any errors produced by the query
query_errors<-querydf$error
# conseguir la respuesta a la query
# nos da un query_result de 3 observaciones (los genes) de 9 variables
query_result<-querydf$response
query_result  # CUIDADO esto cuelga R con datos masivos
sink("query_result.txt")
query_result
sink()
# Create a table with the number of responses from each of the queries:
# crear una tabla con el numero de respuestas para cada una de las queries
query_stats<-data.frame(query_result[c("id","numTotalResults","numResults")])
names(query_stats)[1]<-"query"
query_stats
sink("query_stats.txt")
query_stats
sink()
# Filter from the result list the output of those queries that produced no result
# filtrar de la lista de resultados los outputs de aquellas queries que no devuelven resultado
queries_with_results<- rowSums(query_stats[,c(2,3)])>0
queries_with_results
retrieved_results<-query_result$result[queries_with_results]
retrieved_results  # CUIDADO esto cuelga R con datos masivos
sink("retrieved_results.txt")
retrieved_results
sink()
class(retrieved_results)
results_DF <- do.call(rbind.data.frame, retrieved_results)
sink("results_DF")
results_DF
sink()
class(results_DF)
# test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description,retrieved_results[[1]]$drugInteractions)
test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description)
test
sink("tessst.txt")
test
sink()
# EJEMPLO 1 DEL API
# Ejemplo usando la primera variante
# que encontramos en el VCF file usado como ejemplo
#### first variant found in the VCF file used as example
#### -> chr1 - 18149476 - Ref:G and Alt:A
# COn este link obtenemos anotación para la variante seleccionada
# "http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation?limit=-1&skip=-1&count=false&Output%20format=json&normalize=false
# version corta :
# http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation
library(RCurl)
library(jsonlite)
# guardar el enlace en el objeto query. Para eso se usa la funcion geturl de Rcurl, que descarga URLs
query<-getURL("http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation")
# esta direccion se puede pegar en el navegador para ver la pinta que tiene
# TEST CON OTRA URL
# query <-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/genomic/region/1:18149476-18149476/gene")
# en esta query tenemos lo que es el JSON. Tipo : Large character
query # podemos mostrar el JSON en pantalla
sink("query.txt")
query
sink()
# almacenamos el contenido json de la url en un objeto tipo lista
# este objeto contiene pues toda la informacion de los genes solicitados
querydf<-fromJSON(query)
querydf # CUIDADO esto cuelga R con datos masivos
sink("querydf.txt")
querydf
sink()
## NOTA : warning, error y response estan en la primera linea de la URL
## NOTA : el contenido response es todo el resto
#Get any warnings that may be worth noting
query_warnings<-querydf$warning
#Get any errors produced by the query
query_errors<-querydf$error
# conseguir la respuesta a la query
# nos da un query_result de 3 observaciones (los genes) de 9 variables
query_result<-querydf$response
query_result  # CUIDADO esto cuelga R con datos masivos
sink("query_result.txt")
query_result
sink()
# Create a table with the number of responses from each of the queries:
# crear una tabla con el numero de respuestas para cada una de las queries
query_stats<-data.frame(query_result[c("id","numTotalResults","numResults")])
names(query_stats)[1]<-"query"
query_stats
sink("query_stats.txt")
query_stats
sink()
# Filter from the result list the output of those queries that produced no result
# filtrar de la lista de resultados los outputs de aquellas queries que no devuelven resultado
queries_with_results<- rowSums(query_stats[,c(2,3)])>0
queries_with_results
retrieved_results<-query_result$result[queries_with_results]
retrieved_results  # CUIDADO esto cuelga R con datos masivos
sink("retrieved_results.txt")
retrieved_results
sink()
class(retrieved_results)
results_DF <- do.call(rbind.data.frame, retrieved_results)
sink("results_DF")
results_DF
sink()
class(results_DF)
# test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description,retrieved_results[[1]]$drugInteractions)
test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description)
test
sink("tessst.txt")
test
sink()
# EJEMPLO 1 DEL API
# Ejemplo usando la primera variante
# que encontramos en el VCF file usado como ejemplo
#### first variant found in the VCF file used as example
#### -> chr1 - 18149476 - Ref:G and Alt:A
# COn este link obtenemos anotación para la variante seleccionada
# "http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation?limit=-1&skip=-1&count=false&Output%20format=json&normalize=false
# version corta :
# http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation
library(RCurl)
library(jsonlite)
# guardar el enlace en el objeto query. Para eso se usa la funcion geturl de Rcurl, que descarga URLs
query<-getURL("http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation")
# esta direccion se puede pegar en el navegador para ver la pinta que tiene
# TEST CON OTRA URL
# query <-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/genomic/region/1:18149476-18149476/gene")
# en esta query tenemos lo que es el JSON. Tipo : Large character
query # podemos mostrar el JSON en pantalla
sink("query.txt")
query
sink()
# almacenamos el contenido json de la url en un objeto tipo lista
# este objeto contiene pues toda la informacion de los genes solicitados
querydf<-fromJSON(query)
querydf # CUIDADO esto cuelga R con datos masivos
sink("querydf.txt")
querydf
sink()
## NOTA : warning, error y response estan en la primera linea de la URL
## NOTA : el contenido response es todo el resto
#Get any warnings that may be worth noting
query_warnings<-querydf$warning
#Get any errors produced by the query
query_errors<-querydf$error
# conseguir la respuesta a la query
# nos da un query_result de 3 observaciones (los genes) de 9 variables
query_result<-querydf$response
query_result  # CUIDADO esto cuelga R con datos masivos
sink("query_result.txt")
query_result
sink()
# Create a table with the number of responses from each of the queries:
# crear una tabla con el numero de respuestas para cada una de las queries
query_stats<-data.frame(query_result[c("id","numTotalResults","numResults")])
names(query_stats)[1]<-"query"
query_stats
sink("query_stats.txt")
query_stats
sink()
# Filter from the result list the output of those queries that produced no result
# filtrar de la lista de resultados los outputs de aquellas queries que no devuelven resultado
queries_with_results<- rowSums(query_stats[,c(2,3)])>0
queries_with_results
retrieved_results<-query_result$result[queries_with_results]
retrieved_results  # CUIDADO esto cuelga R con datos masivos
sink("retrieved_results.txt")
retrieved_results
sink()
class(retrieved_results)
results_DF <- do.call(rbind.data.frame, retrieved_results)
sink("results_DF")
results_DF
sink()
class(results_DF)
# test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description,retrieved_results[[1]]$drugInteractions)
test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description)
test
sink("tessst.txt")
test
sink()
# EJEMPLO 1 DEL API
# Ejemplo usando la primera variante
# que encontramos en el VCF file usado como ejemplo
#### first variant found in the VCF file used as example
#### -> chr1 - 18149476 - Ref:G and Alt:A
# COn este link obtenemos anotación para la variante seleccionada
# "http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation?limit=-1&skip=-1&count=false&Output%20format=json&normalize=false
# version corta :
# http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation
library(RCurl)
library(jsonlite)
# guardar el enlace en el objeto query. Para eso se usa la funcion geturl de Rcurl, que descarga URLs
query<-getURL("http://bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/v4/hsapiens/genomic/variant/1%3A18149476%3AG%3AA/annotation")
# esta direccion se puede pegar en el navegador para ver la pinta que tiene
# TEST CON OTRA URL
# query <-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/genomic/region/1:18149476-18149476/gene")
# en esta query tenemos lo que es el JSON. Tipo : Large character
query # podemos mostrar el JSON en pantalla
sink("query.txt")
query
sink()
# almacenamos el contenido json de la url en un objeto tipo lista
# este objeto contiene pues toda la informacion de los genes solicitados
querydf<-fromJSON(query)
querydf # CUIDADO esto cuelga R con datos masivos
sink("querydf.txt")
querydf
sink()
## NOTA : warning, error y response estan en la primera linea de la URL
## NOTA : el contenido response es todo el resto
#Get any warnings that may be worth noting
query_warnings<-querydf$warning
#Get any errors produced by the query
query_errors<-querydf$error
# conseguir la respuesta a la query
# nos da un query_result de 3 observaciones (los genes) de 9 variables
query_result<-querydf$response
query_result  # CUIDADO esto cuelga R con datos masivos
sink("query_result.txt")
query_result
sink()
# Create a table with the number of responses from each of the queries:
# crear una tabla con el numero de respuestas para cada una de las queries
query_stats<-data.frame(query_result[c("id","numTotalResults","numResults")])
names(query_stats)[1]<-"query"
query_stats
sink("query_stats.txt")
query_stats
sink()
# Filter from the result list the output of those queries that produced no result
# filtrar de la lista de resultados los outputs de aquellas queries que no devuelven resultado
queries_with_results<- rowSums(query_stats[,c(2,3)])>0
queries_with_results
retrieved_results<-query_result$result[queries_with_results]
retrieved_results  # CUIDADO esto cuelga R con datos masivos
sink("retrieved_results.txt")
retrieved_results
sink()
class(retrieved_results)
results_DF <- do.call(rbind.data.frame, retrieved_results)
sink("results_DF")
results_DF
sink()
class(results_DF)
# test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description,retrieved_results[[1]]$drugInteractions)
test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description)
test
sink("tessst.txt")
test
sink()
asFrame <- do.call("rbind.fill", lapply(querydf, as.data.frame))
asDataFrame <- fromJSON(query) %>% as.data.frame
install.packages("magrittr")
install.packages("data.tree")
library(RinR)
install.packages("RinR")
R.Version()
library(cellbaseR)
try(cb <- CellBaseR())
variant <- "1:169549811:A:G"
try(res2 <- getVariant(object=cb, ids=variant, resource="annotation"))
res2 <- cbData(res2)
str(res2, 1)
testRinRresult <- res2
query<-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/feature/gene/BRCA2,BRCA1,KRAS/info")
library(RCurl)
library(jsonlite)
query<-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/feature/gene/BRCA2,BRCA1,KRAS/info")
query<-getURL("bioinfo.hpc.cam.ac.uk/cellbase/webservices/rest/latest/hsapiens/feature/gene/BRCA2,BRCA1,KRAS/info")
query # podemos mostrar el JSON en pantalla
querydf<-fromJSON(query)
query_warnings<-querydf$warning
query_errors<-querydf$error
query_result<-querydf$response
query_stats<-data.frame(query_result[c("id","numTotalResults","numResults")])
names(query_stats)[1]<-"query"
query_stats
queries_with_results<- rowSums(query_stats[,c(2,3)])>0
queries_with_results
retrieved_results<-query_result$result[queries_with_results]
test<-data.frame(retrieved_results[[1]]$id,retrieved_results[[1]]$name,retrieved_results[[1]]$description,retrieved_results[[1]]$drugInteractions)
test
View(test)
View(test)
install.packages("installr"); library(installr) # install+load installr
updateR() # updating R.
load("~/.RData")
load("~/GitHub/vcf_pk/.RData")
load("~/GitHub/vcf_pk/annotatedVarTable.RData")
########### [Code] Main method ########
getChosenAnnotTable <- function(chosen_annot, basicTable, annotVariants_table) {
############# [Code] Load libraries #############
library(RCurl)
library(jsonlite)
library(cellbaseR)
library(dplyr)
library(tidyr)
############# [Code] Method to process cells containing a dataframe #############
# This function will convert any cell containing a dataframe in readable information
# cell_to_convert <- annot_cell # For TESTING purpose
simplifyDFcell <- function (cell_to_convert) {
print ("Processing a dataframe") # testing line
# Create a new dataframe from the cell
cell_df <- data.frame(cell_to_convert)
# To know what classes are inside the dataframe
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
# Check if there still are a dataframe inside the new dataframe
if ('data.frame' %in% classes_vec) {
cell_df <- flatten(cell_df)
class_info <- lapply(cell_df, class)
classes_vec <- as.character(class_info)
}
# Check if there is a list inside the new dataframe
i <- 1
for (class in classes_vec) {
if (class == "list") {
cell_df[,i] <- as.character(cell_df[,i])
}
i <- i + 1
}
# The result will be a new row created from the cell
return(cell_df)
}
############# [Code] Main method ############
# Get the index of the chosen annotation
index_annot <- grep(chosen_annot, colnames(annotVariants_table))
# Extract, as a single variable, the chosen annotation from the table
annot_column <- annotVariants_table[,index_annot]
# Declare the dataframe that will contain all the info of the chosen annotation
chosen_annot_table <- data.frame()
# Determinate the class of all the cells inside the column
column_classes <- lapply(annot_column, class)
# For each cell of the annotation column, loop to extact the content of the cell
i = 1
for (annot_cell in annot_column) {
# Print info of the cell being analyzed
print (paste("Variant", i, "with class", class(annot_cell), "and lenght:",length(annot_cell)))
print (paste("dimension",(dim(annot_cell))))
# Assign variables to start the analyze
data_class <- class(annot_cell)
data_length <- length(annot_cell)
basic_row <- basicTable[i,]
# print (str(annot_column[i])) # testing line
if (data_length == 0) { # In case the cell would have no result for this annotation
print ("Processing empty cell")
annotated_row <- basic_row
# annotated_row[, chosen_annot] <- "No result"
} else if (data_class == "data.frame") { # In case the cell would contain a dataframe
# Apply the function  to produce a row/df from the cell
annotation_row <- simplifyDFcell(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else if (data_class == "list") { # In case the cell would contain a list
annotation_row <- as.character(annot_cell)
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
} else {# In case the cell is not problematic
annotation_row <- annot_cell
# Build a row with the chosen annotation of the current variant
# and bind it to basic table
annotated_row <- cbind(basic_row, annotation_row)
}
print ("Building the annotated table") # testing line
chosen_annot_table <- bind_rows(chosen_annot_table, annotated_row)
i = i + 1
print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")# testing line
}
return(chosen_annot_table)
}
########### [Code] Determinate if running in TERR or standard R version #############
isTERR<-R.Version()
Rversion<-NULL
if (!is.null(isTERR[["TERR.version"]])) {
########### [TIBCO] Load RinR library ###################
library(RinR)
########### [TIBCO] Determinate R interpreter location ########
Rversion <- makeREvaluator("R", RHome = "C:/Program Files/R/R-3.4.1")
############ [TIBCO] Load variables ###############
# Load the annotated table, stored in memory as a Blob Object created by script "cellbaseR_Query_getVariant"
annotVariantsSObject <- BlobToSObject(annotVariantsBlob)
annotVariants_table <- annotVariantsSObject
# For testing prupose: you can pre-set the annotation "geneDrugInteraction"
# chosen_annot <- availableAnnots[12]
########### [TIBCO] Create the REvaluate object ########
AnnotatedTable <- REvaluate({
chosen_annot_table <- getChosenAnnotTable(chosen_annot, basicTable, annotVariants_table)
chosen_annot_table
},
data = list(getChosenAnnotTable = getChosenAnnotTable, annotVariants_table = annotVariants_table, chosen_annot = chosen_annot, basicTable = basicTable)
# ,
# REvaluator = Rversion,
# verbose	= TRUE
)
} else {
########### [RStudio] Set Working directory ############
setwd("C:\\Users\\FollonIn\\Documents\\GitHub\\vcf_pk")
########### [RStudio] Get the input variables ############
chosen_annot = availableAnnots[4]
# availableAnnots, basicTable, annotVariants_table
# They should already be loaded in global environment and come from script 3.cellbaseR_Query_getVariant
########### [RStudio] Execute main method ###########
chosen_annot_table <- getChosenAnnotTable(chosen_annot, basicTable, annotVariants_table)
########### [RStudio] Print the table in a txt file ###########
# Works only with basic table
file_path <- paste("test_files\\annotated_table_",chosen_annot, ".txt",sep = "")
try(write.table(chosen_annot_table,file_path, append = FALSE, sep="\t",row.names=FALSE))
}
View(chosen_annot_table)
########### [TESTING] Control classes of the chosen annotation table #######
# Just to be sure this table is suitable for TIBCO
TEST_classes <- lapply(chosen_annot_table, class)
TEST_classes
chosen_annot
